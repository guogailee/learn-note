## 本书基于JDK1.7

## Java获得认可的原因

- 语言结构严谨，面向对象
- 一次编写，到处运行
- 提供了相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界
- 实现了热点代码检测和运行时编译与优化
- 拥有完善的应用程序接口，有无数的第三方类库

## JDK

Java程序设计语言+Java虚拟机+Java API类库

## JRE(Java Runtime Environment)

Java AP类库子集Java SE API+Java虚拟机

## HotSpot VM

JDK和OpenJDK所带的虚拟机

## Dalvik VM

Android平台的虚拟机

## Java是解释执行的么？

```
解释执行：将编译好的字节码一行一行地翻译为机器码执行。

编译执行：以方法为单位，将字节码一次性翻译为机器码后执行。
```

```
HotSpot虚拟机中，提供了两种编译模式，解释执行和即时编译(JIT:Just in time)。
解释执行即逐条翻译字节码为可运行的机器码，优势是不用等待。
即时编译以方法为单位，将字节码一次性翻译为机器码，实际运行效率更高。
如何选择呢？二八定律，大部分过不常用的代码，不需要消耗时间去编译为机器码，解释执行，小部分热点代码，就即时编译为机器码(热点代码，编译一次，反复运行)高效执行，提供运行效率。
```

## 自己动手编译Open JDK

- 源代码下载地址

  ```
  http://download.java.net/openjdk/jdk7/promoted/b147/openjdk-7-fcs-src-b147-27_jun_2011.zip
  ```

- 配置编译参数

- make开始编译

## 运行时数据区

![jvm运行数据区](img/jvm运行数据区.jpeg)

### 程序计数器

```
1.线程私有

2.代表的是当前线程所执行的字节码的行号指示器，字节码解释器工作就是通过改变计数器的值来选取下一条需要执行的字节码指令

3.如果当前线程执行的是java方法，计时器的值为正在执行的字节码指令地址
  如果当前线程执行的是Native方法，计时器的值为空
  
4.唯一一个不会发生OutOfMemoryError的区域  
```

### Java虚拟机栈

```
1.线程私有，生命周期与线程相同

2.代表的是Java方法执行的内存模型：
每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
每个方法从调用直到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈

3.局部变量表，存放的内容：编译器可知的各种基本数据类型、对象引用、returnAddress类型，它的大小在编译完成后就是固定的

4.可能抛出的异常有StackOverflowError & OutOfMemoryError
```

### 本地方法栈

```
1.线程私有

2.类似Java虚拟机栈，区别是为Native方法服务，而Java虚拟机栈是为Java方法服务

3.可能抛出的异常有StackOverflowError & OutOfMemoryError
```

### Java堆

```
1.线程共享

2.目的：存放对象实例和数组

3.如何回收内存：被垃圾收集器采用分代收集算法回收

4.可扩展，通过-Xmx -Xms控制

5.可能抛出的异常有OutOfMemoryError
```

### 方法区

```
1.线程共享

2.目的：存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

3.如何回收内存：目前是永久代实现

4.可能抛出的异常有OutOfMemoryError，内存申请不到的时候就会抛出这个异常
```

包含：

- 运行时常量池

  ```
  1.内容：存放的是class文件编译后生成的各种字面量和符号引用
  
  2.动态性：运行期间也可以将新的常量放入池中，
  比如String.intern()，s.intern()的意思是，如果s的值在常量池中存在，就直接返回，否则放入常量池中并返回，应用这个特性可以节省很大内存。
  ```

## 直接内存

- Direct Memory

  ```
  1.不是虚拟机运行时数据区，也不是JVM规范中的内存，是本机直接内存
  
  2.应用：native函数直接分配堆外内存，再通过堆中的一个DirectByteBuffer对象持有直接内存的引用，用于显著提高性能
  
  3.可能抛出的异常有OutOfMemoryError
  ```

## JVM对象的创建、布局、如何访问的

### 对象的创建过程

```
虚拟机遇到一条new指令，执行的流程如下
1.类加载检查，没有加载就先类加载

2.为对象分配内存，分配的大小在类加载的过程就已知

3.虚拟机将分配到的内存空间都初始化为零值

4.虚拟机对对象进行必要的设置，比如对象属于哪个类，对象的哈希码，分代年龄等信息

5.执行init方法

6.对象创建完成
```

内存分配方式

```
两种方式：
一、指针碰撞：堆中内存是绝对规整的，用过的内存放在一边，空闲的在另一边，通过一个指针移动所需分配的内存大小
二、空闲列表：堆中内存不是绝对规整的，维护一个列表，从列表中找内存分配
根据垃圾收集器是有否压缩整功能来选择，CMS基于标记清除算法的收集器，就采用的是空闲列表方式分配内存
```

### 对象的内存布局

```
组成：
1.对象头：
第一部分：存储对象自身运行时数据，哈希码，锁状态标志，GC分代年龄、线程持有的锁，大小为32bit/64
第二部分：类型指针，确定对象是哪个类的实例
第三部分：数组大小，可选

2.实例数据：
各种类型字段的内容，包含父类继承下来的

3.对齐填充：
占位符，填充保证对象是8的整数倍字节

```

### 对象的访问定位

```
通过栈中的reference来访问堆中的具体对象的方式：
1.句柄
reference存储对象的句柄地址，通过对象句柄再访问对象
ref->对象句柄->对象
优点：对象回收移动，但是ref中存储的对象句柄是固定的


2.直接指针（HotSpot使用的这种方式）
reference存储的是对象的地址
ref->对象
优点：速度更快
```

![句柄访问对象](img/句柄访问对象.jpeg)

![直接指针访问](img/直接指针访问.jpeg)

### 虚拟机参数

```
指定堆的最小值
-Xms20m 
指定堆的最大值
-Xmx20m
指定当虚拟机出现内存溢出dump出当前的内存堆快快照
-XX:+HeapDumpOnOutOfMemoryError 
指定Java虚拟机栈的大小
-Xss128k
```

### 虚拟机异常如何解决

- 内存溢出

  ```
  1.根据dump出的快照，分析是否有内存泄露
  2.对比物理机器大小调整堆大小
  ```

- 建立过多的线程导致的栈内存溢出如何解决

  ```
  1.减少堆内存和栈容量，换取更多的线程
  
  操作系统内存-堆内存-方法区内存 约等于 虚拟机栈内存
  ```

- 

