## 设计模式的分类

### 创建型模式

```
5种：
工厂方法模式
抽象工厂模式
单例模式
建造者模式
原型模式
```

### 结构型模式

```
7种：
适配器模式
装饰器模式
代理模式
外观模式
桥接模式
组合模式
享元模式
```

### 行为型模式

```
11种：
策略模式
模板方法模式
观察者模式
迭代子模式
责任链模式
命令模式
备忘录模式
状态模式
访问者模式
中介者模式
解释器模式
```

### 并发型模式

### 线程池模式

## 创建型模式

### 单例模式

```
静态内部类实现
public class Singleton { 

    private static class SingletonHolder { 

        private static final Singleton INSTANCE = new Singleton(); 

    } 

    private Singleton (){} 

    public static final Singleton getInstance() { 

        return SingletonHolder.INSTANCE;

    } 

}
```

```
volatile+双重检查加锁实现
public class Singleton{

private volatile static Singleton instance;

public static Singleton getSingleton() {

    if (instance == null) {                       

        synchronized (Singleton.class) {

            if (instance == null) {               

                instance = new Singleton();

            }

        }

    }

    return instance ;

}

}
不加volatile会有问题：
instance = new Singleton();
1.分配对象的内存空间
2.初始化对象
3.设置instance指向刚分配的内存地址
的顺序会被重新排序
```

```
枚举实现

```

### 策略模式

```
定义：
接口定义方法，实现类有多种
```

```
应用场景：
1.交易下单，不同模式不同实现类
```

### 模板方法模式

```
定义：
抽象类定义了算法的框架，将某些步骤延迟到子类执行
```

```
应用场景：
```

### 代理模式

**定义**

- 代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象，这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。

  ![proxy](/Users/guogai/Documents/learn-note/img/proxy.png)

**静态代理**

- 静态代理：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。

- 缺点：因为代理对象与目标对象需要实现一样的接口，所以会有很多代理类，类太多，同时，一旦接口增加方法，目标对象与代理对象都要维护。

- 如何解决静态代理的缺点呢？使用动态代理。

- 例子

  ```
  //目标对象接口
  public interface UserDao {
      void save();
  }
  
  //目标对象
  public class UserDaoImpl implements UserDao {
      public void save() {
          System.out.println("已经保存数据");
      }
  }
  
  //代理对象
  public class UserDaoProxy implements UserDao {
      private UserDao userDao;
  
      public UserDaoProxy(UserDao userDao) {
          this.userDao = userDao;
      }
  
      public void save() {
          System.out.println("事务开始");
          userDao.save();
          System.out.println("事务结束");
      }
  }
  
  //test
  public class Test {
      public static void main(String[] args) {
          //目标对象
          UserDao userDao = new UserDaoImpl();
          //把目标对象传给代理对象，建立代理关系
          UserDaoProxy userDaoProxy = new UserDaoProxy(userDao);
          //执行代理对象的方法
          userDaoProxy.save();
      }
  }
  
  //输出
  事务开始
  已经保存数据
  事务结束
  ```

**动态代理**

- JDK实现：利用JDK的API，动态的在内存中构建代理对象。

  - api

    ```
       public static Object newProxyInstance(ClassLoader loader,
                                              Class<?>[] interfaces,
                                              InvocationHandler h)
        {
        //...
        }
    ```

  - 总结：目标对象一定要实现接口，否则不能用动态代理。

  - 例子

    ```
    //目标对象接口
    
    //目标对象
    
    //代理工厂
    public class ProxyFactory {
        private Object target;
    
        public ProxyFactory(Object target) {
            this.target = target;
        }
    
        public Object newProxyInstance() {
            return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                    target.getClass().getInterfaces(),
                    new InvocationHandler() {
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            System.out.println("事务开始");
                            Object result = method.invoke(target, args);
                            System.out.println("事务结束");
                            return result;
                        }
                    }
            );
        }
    }
    
    
    //test
    public class Test {
        public static void main(String[] args) {
            //目标对象
            UserDao userDao = new UserDaoImpl();
            System.out.println(userDao.getClass());
    
            //代理对象
            UserDao proxy = (UserDao) new ProxyFactory(userDao).newProxyInstance();
            System.out.println(proxy.getClass());
    
            proxy.save();
        }
    }
    
    //输出
    class www.blue.com.proxy.staticproxy.UserDaoImpl
    class com.sun.proxy.$Proxy0
    事务开始
    已经保存数据
    事务结束
    ```

- cglib实现

  - 也叫子类代理，在内存中构建一个子类对象从而实现对目标对象功能的扩展。

  - 底层通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。

  - 例子

    ```
    //目标对象
    public class UserDaoImpl {
        public void save() {
            System.out.println("保存数据");
        }
    }
    
    //代理工厂
    public class ProxyFactory implements MethodInterceptor {
        private Object target;
    
        public ProxyFactory(Object target) {
            this.target = target;
        }
    
        public Object getProxyInstance() {
            //工具类
            Enhancer enhancer = new Enhancer();
            //设置父类
            enhancer.setSuperclass(target.getClass());
            //设置回调函数
            enhancer.setCallback(this);
            //创建子类
            return enhancer.create();
    
        }
    
        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
            System.out.println("开始事务");
            Object result = method.invoke(target, objects);
            System.out.println("结束事务");
            return result;
        }
    }
    
    //Test
    public class Test {
        public static void main(String[] args) {
            //目标对象
            UserDaoImpl target = new UserDaoImpl();
            //代理对象
            UserDaoImpl proxy = (UserDaoImpl) new ProxyFactory(target).getProxyInstance();
    
            proxy.save();
        }
    }
    
    //输出
    开始事务
    保存数据
    结束事务
    ```

**应用**

- spring aop

  ```
  AOP使用JDK动态代理和cglib动态代理技术来实现
  ```

