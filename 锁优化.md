# 重量级锁

```
使用synchronized即可使用内置锁，模型是监视器锁，也就是monitor，对应操作系统中的互斥量mutex。成本高，所以称为重量级锁。
```

# 锁优化技术

## 版本

```
JDK1.6开始，JVM对锁进行了各种优化
```

## 自旋锁

```
自旋锁就是在请求获取锁，又不能马上获取到时，让当前线程在不放弃处理器执行时间的情况下执行忙循环，尝试等待锁被释放，再获取锁。

目的是为了节省线程挂起和恢复的开销。

忙循环不是无限制的，默认是10次，通过JVM参数-XX:PreBlockSpin控制
```

## 自适应自选锁

```
基于自旋锁，只是自旋的次数不是固定的，而是自适应的，由前一次在同一个锁上的自旋次数和锁的拥有者的状态来决定。

如果前面线程成功获取锁并且正常运行，那么本地获取锁的可能性就很大，所以自旋的次数相对多一些；如果前面线程很少成功获取锁，那么本次获取锁的概率很小，就可能不执行自旋了。
```

## 锁粗化

```
如果在一段代码中同一个线程反复获取、释放同一个对象的锁，将会产生不必要的开销，所以需要把锁的范围扩大，对同一个对象的锁操作只进行一次，在循环开始前获取，在循环结束后释放。
```

## 锁消除

```
锁消除是指JIT在运行时分析，使用了锁的同步代码在实际运行时不可能存在共享数据被竞争的情况，对锁进行去除。比如局部变量在方法内部加锁控制，可以去掉锁。
```

## 偏向锁

```
偏向锁就是如果线程持有了锁，在后续的过程中，只要该锁没有被其它线程持有，那么持有偏向锁的线程将不再需要进行同步操作。这个偏向锁的相关信息是保存在Java对象的对象头中的。

偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word(对象头)中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。

只有初始化时需要一次CAS。
```

## 轻量级锁

```
轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。

使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。

轻量级锁每次申请、释放锁都至少需要一次CAS
```

## 偏向->轻量级锁->重量级锁

```
偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
重量级锁：有实际竞争，且锁竞争时间长。
```

## 锁膨胀过程

![锁优化](img/锁优化.png)