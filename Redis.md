## 缓存雪崩

```
key的过期时间设置的过于集中，到了过期时间，大量的数据失效，如果有大量的用户涌入，就有可能造成缓存雪崩

如何解决：
在时间上加一个随机值，使得过期时间分散一些。
setRedis（Key，value，time + Math.random() * 10000）；
```

## 缓存穿透

```
缓存穿透是指缓存和数据库中都没有的数据,用户不断发起请求,导致数据库压力过大，严重会击垮数据库。

如何解决：
1.接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
但是你没对分页参数的大小做限制，调用的人万一一口气查 Integer.MAX_VALUE 一次请求就要你几秒，多几个并发你不就挂了么？

2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值

3.布隆过滤器（Bloom Filter）这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。
```

## 缓存击穿

```
指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库

如何解决：
设置热点数据永远不过期
```

## Redis分布式锁

```
setnx key value expire time 一条指令
```

## 如何查找海量数据

```
假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

使用keys指令可以扫出指定模式的key列表。

缺点：
keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。

改进：
这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
```

