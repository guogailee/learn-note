## 设计目标

大并发、高性能、高可用的分布式系统

## 库存如何扣减

**redis+lua脚本**

```
1.提前把库存加载到redis中
2.扣减库存，不在数据库做，放redis做，可以减轻mysql的压力
3.最后异步的将库存从redis同步到数据库
4.数据库乐观锁实现
```

```
redis2.6 版本支持lua脚本，原子性，实现库存扣减
```

## 请求链接安全层面

**动态化url**

```
下单url加密后返回给前端，下单的时候再后端校验
```

## 动静分离层面

**数据尽量少**

```
1.尽量简化秒杀页面
2.动静分离，刷新不需要刷新整个页面，而是只请求少量的动态数据。
```

## 资源静态化

**cdn**

```
1.前后端分离，前端资源提前上cdn，不经过后端服务器
```

## 前端按钮控制

**按钮置灰**

```
前端定时请求服务器，获取最新时间，到时间点再给按钮可用
```

## 应用服务器层面

**nigix集群负载均衡**

```
nigix并发几万，tomcat并发几百
临时租服务器，用nigix负载均衡
```

**nigix恶意请求拦截**

```
限制同一个ip多次请求
```

## 削峰填谷

```
作用：节省服务器资源&保护系统不崩溃

方式：
1.MQ消息队列缓冲
2.答题：限制秒杀器，限制无效请求-需要有一个答题系统配合
```

## 缓存层面

**redis集群**

```
读多写少，热点数据提前放入缓存
1.方案：redis集群，主从同步，读写分离，哨兵监控，并且开启持久化
2.热点数据放在独立部署的机器的内存中缓存，不走公共缓存集
```

## 数据库层面

**秒杀独立库**

```
就算秒杀库崩了，不影响其他服务
```

## 限流&降级&熔断&隔离

**前端限流**

```
前端不能让用户无限制点，每隔一秒点一下
```

**后端限流**

```
限流，降级，熔断，防止服务完全不可用
```

**隔离**

```
独立部署秒杀系统
```

