## 什么是死锁

```
多个线程因竞争资源而造成的一种互相等待，如果没有外力作用，这些线程都将无法继续执行。
```

## 死锁产生的必要条件

- 互斥条件

  ```
  线程要求所分配的资源进行排他性控制，即在一段时间内某资源只能被一个线程所占有，此时，如果有有其他线程请求该资源，请求线程只能等待。
  ```

- 不剥夺条件

  ```
  线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，只能由获得该资源的线程自己来释放。
  ```

- 请求和保持条件

  ```
  线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不放。
  ```

- 循环等待条件

  ```
  存在一种线程资源的循环等待链，链中每一个线程所获得的资源同时被链中下一个线程所请求。
  ```

- 只要任何一个条件不成立，死锁就不会发生，发生了死锁，四个条件肯定都成立了

## 如何避免死锁

- 破坏互斥条件-无法破坏，否则不会发生死锁

- 破坏”不可剥夺条件“&”请求和保持条件“-通过超时和回退机制

  ```
  如果一个线程没有在给定的时间内成功获得所有需要的锁，则进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。
  ```

- 破坏循环等待条件-通过加锁顺序机制

  ```
  按照顺序加锁是一种有效的死锁预防机制，多个线程按照同样的顺序加锁
  ```

- 死锁检测-针对不能按照顺序加锁的和不能超时回退的场景

  ```
  每当当一个线程请求锁失败时，会遍历锁的关系图，看是否会有死锁发生，如果有，就释放所有的锁，回退，等待一段随机的时间后重试。
  ```

  