## 非公平lock()

```
1.当前线程尝试setState成功，那么就获取了锁，state=1,当前拥有锁的线程设置为当前线程

2.其他线程来获取锁，再尝试setState()2次，失败，自旋-会初始化等待队列head,并把tail=head，新建一个node加入队列尾部，形成head->tail的队列

3.如果当前线程对应的节点在head节点后面，尝试setState()，成功，获取锁，设置当前节点为head，清空链表尾部；失败，自旋设置pred节点的waitStatus为-1（它的下一个节点需要被唤醒），清除head和当前节点之间取消的node&&park当前线程，并且中断当前线程，挂起，等待被唤醒
```

## 公平lock()

```
1.判断state，如果为0并且同步队列尾部没有其他节点在等待，就抢占锁；反之，直接加入同步队列的尾部。
```

## unlock()

```
1.state-1
2.唤醒下一个-1的节点，调用 LockSupport.unpark()，让它唤醒后，抢占lock
```

## 条件队列与同步队列的关系

```
同步队列转换到条件队列：
同步队列的头结点，此时拥有锁，调用await()后，阻塞，加入条件队列的尾部；

条件队列转换到同步队列：
调用signal，从条件队列的取出第一个结点，加入同步队列的尾部，参与锁的竞争
```

