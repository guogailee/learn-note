## 适配器模式

- 场景

  ```
  用户中心提供了一个根据token查询用户的接口
  UserService:
  UserDTO queryUserByToken(String token);
  
  过了一周，用户中心的人说，我们接口升级了，你们交易需要改一下，新接口是
  CustomerService:
  CustomerDTO queryUser(String token);
  
  为了避免我们多处调用用户中心的业务代码变更，我们采用适配器模式里的对象适配器，定义了我们的用户服务
  RemoteUserService:
  User queryUserByToken(String token);
  
  RemoteUserServiceImpl:(适配器)
  @Autowired
  private CustomerService customerService;
  User queryUserByToken(String token){
     CustomerDTO customerDTO =  customerService.queryUser(token);
     return CustomerDTOToUserMapper.convertCustomerDTOToUser();
  }
  
  我们的接口没有那个功能，别人的有，注入实例对象，在我们的接口中调用实例对象的方法，对象适配器，使用的是组合的方式。
  ```

- 适配器模式

  - 定义

    ```
    将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
    ```

  - 对象适配器类图

    ```
    通过组合实现
    ```

    ![image-20190625111945271](/var/folders/qh/skk3h6cj2w51d92dj2wb57m40000gn/T/abnerworks.Typora/image-20190625111945271.png)

  - 类适配器类图

    ```
    //demo
    通过继承实现
    ```

    ![image-20190625112355645](/var/folders/qh/skk3h6cj2w51d92dj2wb57m40000gn/T/abnerworks.Typora/image-20190625112355645.png)

  - 接口适配器

    ```
    //demo
    想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现
    ```

  - 常见应用

    ```
    讨论：
    ```

## 责任链模式

- 场景

  ```
  小明要去上学，去上学之前要完成几件事(刷牙，洗脸，吃早饭...)才可以出门。
  ```

- 不使用模式，用面向过程的代码实现

  ```
  //demo
  ```

  问题：

  1.违背了开闭原则，没有做到对扩展开放，对修改关闭，当非核心事情(刷牙、洗脸、吃早饭...)增删，或者调整顺序，我们需要去相应的修改核心事情的代码(上学)

- 引入责任链模式

  ```
  //demo
  public class Test {
      public static void main(String[] args) {
          //清单
          PreList preList = new PreList();
          preList.setBrush(true);
          preList.setWashFace(true);
          preList.setHaveBreakfast(true);
  
          //上学
          Study study = new Study();
  
          //解耦核心和非核心
          AbstractPrepareFilter haveBreakfast = new HaveBreakfastFilter(null);
          AbstractPrepareFilter washFace = new WashFaceFilter(haveBreakfast);
          AbstractPrepareFilter brush = new BrushFilter(washFace);
          brush.doFilter(preList, study);
  
      }
  }
  
  改写法存在的问题？
  1.增加减少责任链对象，需要修改调用方
  2.调用方需要思考一下最后调用哪一个filter具体实例
  
  如何改进？
  
  public class Test {
  
      public static void main(String[] args) {
          PreList preList = new PreList();
          preList.setBrush(true);
          preList.setWashFace(true);
          preList.setHaveBreakfast(true);
  
          BrushFilter brushFilter = new BrushFilter();
          WashFaceFilter washFaceFilter = new WashFaceFilter();
          HaveBreakfastFilter haveBreakfastFilter = new HaveBreakfastFilter();
  
          Study study = new Study();
          FilterChain filterChain = new FilterChain(study);
          filterChain.addFilter(brushFilter);
          filterChain.addFilter(washFaceFilter);
          filterChain.addFilter(haveBreakfastFilter);
          filterChain.doFilter(preList, filterChain);
  
      }
  }
  
  bean交给spring管理
  <bean id="filterChain" class="xxx.FilterChain">
  	<property name="prepareFilterList">
  		<list>
  			<ref bean="brushFilter" />
  			<ref bean="washFaceFilter" />
  			<ref bean="haveBreakfastFilter" />
  		</list>
  	</property>
  </bean>
  
  ```

  - 责任链模式定义-一种行为模式

    ```
    很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出请求的客户端并不知道链上的哪一个对象最终处理这个请求，从而在不影响客户端的情况下实现动态地组织和分配责任。
    ```

  - 解决什么问题的

    ```
    请求发送者和请求处理者之间的松耦合，抽象非核心的功能，用链式调用的方式处理非核心功能。
    ```

  - 类图

    ![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1561973315&di=6dea8e0db9515bd0d9371bd74c3b4d54&imgtype=jpg&er=1&src=http%3A%2F%2Fimage.laijianfeng.org%2F20181030205553.jpg)

  - 常见应用

    ```
    讨论：
    ```