## 分布式事务场景

```
开启分布式事务
1.插入员工数据
2.插入财务数据
3.插入请假数据
提交分布式事务/回滚
```

## 分布式事务方案

### 两阶段提交方案

**过程**

```
第一阶段：事务管理器询问事务参与者是否可以执行
第二阶段：事务参与者执行
```

**应用场景**

```

```

## TCC方案

 **过程**

```
Try：对各个服务的资源进行检测以及对资源进行锁定
Confirm：在各个服务中执行实际的操作
Cancel：如果任何一个业务方法执行出错，回滚已经执行成功的
```

**应用场景**

```
1.支付/交易严格要求的场景
(车辆交易，锁车成功，下单失败，异常单系统解锁库存是某种意义上TCC)
```

**缺点**

```
1.依赖自己写回滚代码，回滚代码巨大，每个业务回滚逻辑不一样
```

## 本地消息表方案

**过程**

```
1.A系统在自己本地一个事务里操作同时，插入一条数据到消息表
2.A系统将消息发送到MQ
3.B系统接收到消息后，在一个事务里，往自己本地消息表里插入一条数据，同时执行业务操作，如果这个消息已经被处理过了，那么事务回滚，保证不会重复处理消息
4.B系统执行成功后，更新自己本地消息表的状态，以及A系统消息表的状态
5.如果B系统执行失败，就不会更新消息表状态，那么此时系统A会定期扫描自己的消息表，如果有没有处理的消息，会再次发送到MQ中，让B再次处理
6.这个方案保证了最终一致性，哪怕B事务失败了，A会不断发送消息到MQ，直到B成功
```

**应用场景**

```

```

**缺点**

```
1.依赖数据库事务，高并发场景扩展比较难
```

## 可靠消息最终一致性方案-采用

**过程**

```
1.A系统先发送一个prepared消息到MQ
2.如果prepared的消息发送成功，那么接着执行本地事务，如果成功，就告诉mq发送确认消息，如果失败就告诉mq回滚消息
3.如果发送了确认消息，那么此时B系统会收到确认消息，然后执行本地事务
4.mq会自动轮询所有的prepared消息，回调你的接口，看是发送确认消息，还是回滚消息
5.B系统处理消息失败，会不断重试直到成功
```

**应用场景**

```
结合RocketMQ就可以，可以用在大多数分布式系统中，资金系统用TCC。
```

## 经验

```
1.99%的分布式接口调用，不要做分布式事务，直接监控发邮件，打印日志，数据订正，成本比上分布式事务低很多

2.分布式事务带来系统复杂性增加，性能下降

3.做权衡

4.一般对资金、交易做分布式事务，100%保证不出错
```

